
const config_path = joinpath(@__DIR__, "ext.jl")
const previous_config_path = config_path * ".bak"

function write_ext(config, path)
    open(path, "w") do io
        println(io, "# autogenerated file, do not edit")
        for (key,val) in config
            println(io, "const $key = $(repr(val))")
        end
    end
end

function read_ext(path)
    config = Dict{Symbol,Any}()
    r = r"^const (\w+) = (.+)$"
    open(path, "r") do io
        for line in eachline(io)
            m = match(r, line)
            if m != nothing
                config[Symbol(m.captures[1])] = eval(Meta.parse(m.captures[2]))
            end
        end
    end
    return config
end

function main()
    ispath(config_path) && mv(config_path, previous_config_path; remove_destination=true)
    config = Dict{Symbol,Any}()


    ## discover stuff

    VERSION >= v"0.7.0-DEV.2576" || error("This version of LLVM.jl requires Julia 0.7")

    libllvm_name = if Sys.isapple()
        "libLLVM.dylib"
    elseif Sys.iswindows()
        "LLVM.dll"
    else
        "libLLVM.so"
    end

    bindir = if VERSION >= v"0.7.0-DEV.3003"
        Sys.BINDIR
    else
        JULIA_HOME
    end
    libdir = joinpath(dirname(bindir), "lib")
    libllvm_paths = if Sys.iswindows()
        # TODO: Windows build trees
        [joinpath(bindir, libllvm_name)]
    else
        [joinpath(libdir, libllvm_name),            # build trees
         joinpath(libdir, "julia", libllvm_name)]   # dists
     end

    @debug "Looking for $(libllvm_name) in $(join(libllvm_paths, ", "))"
    filter!(isfile, libllvm_paths)
    isempty(libllvm_paths) && error("Could not find $(libllvm_name), is Julia built with USE_LLVM_SHLIB=1?")
    config[:libllvm_path] = first(libllvm_paths)

    config[:libllvm_version] = Base.libllvm_version::VersionNumber
    vercmp_match(a,b)  = a.major==b.major &&  a.minor==b.minor
    vercmp_compat(a,b) = a.major>b.major  || (a.major==b.major && a.minor>=b.minor)

    llvmjl_wrappers = filter(path->isdir(joinpath(@__DIR__, "..", "lib", path)),
                             readdir(joinpath(@__DIR__, "..", "lib")))

    matching_wrappers = filter(wrapper->vercmp_match(config[:libllvm_version],
                                                     VersionNumber(wrapper)),
                               llvmjl_wrappers)
    config[:llvmjl_wrapper] = if !isempty(matching_wrappers)
        @assert length(matching_wrappers) == 1
        matching_wrappers[1]
    else
        compatible_wrappers = filter(wrapper->vercmp_compat(config[:libllvm_version],
                                                            VersionNumber(wrapper)),
                                     llvmjl_wrappers)
        isempty(compatible_wrappers) || error("Could not find any compatible wrapper for LLVM $(config[:libllvm_version])")
        last(compatible_wrappers)
    end

    # TODO: figure out the name of the native target
    config[:libllvm_targets] = [:NVPTX, :AMDGPU]

    # backwards-compatibility
    config[:libllvm_system] = false
    config[:configured] = true


    ## (re)generate ext.jl

    if isfile(previous_config_path)
        @debug "Checking validity of existing ext.jl..."
        previous_config = read_ext(previous_config_path)

        if config == previous_config
            @info "LLVM.jl has already been built for this toolchain, no need to rebuild"
            mv(previous_config_path, config_path; remove_destination=true)
            return
        end
    end

    write_ext(config, config_path)

    return
end

main()
